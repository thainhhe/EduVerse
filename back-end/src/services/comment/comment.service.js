const Comment = require("../../models/Comment");
const Forum = require("../../models/Forum");
const User = require("../../models/User");
const {
  STATUS_CODE,
  SYSTEM_MESSAGE,
  COMMENT_ERROR_MESSAGE,
} = require("../../config/enum/index");
const flattenToLevel3 = (comment, level = 1) => {
  // N·∫øu ƒëang ·ªü c·∫•p 3
  if (level === 2) {
    const deepChildren = [];

    // H√†m ƒë·ªá quy gom to√†n b·ªô con ch√°u s√¢u h∆°n
    const collectDeepChildren = (node) => {
      if (!node.childComments) return;
      node.childComments.forEach((child) => {
        deepChildren.push(child);
        collectDeepChildren(child);
      });
    };

    // Gom to√†n b·ªô con s√¢u h∆°n c·∫•p 3
    comment.childComments.forEach((child) => collectDeepChildren(child));

    // B·ªè c√¢y c≈©, ch·ªâ gi·ªØ unique
    const uniqueChildren = [];
    const seen = new Set();
    [...comment.childComments, ...deepChildren].forEach((c) => {
      if (!seen.has(c._id.toString())) {
        seen.add(c._id.toString());
        uniqueChildren.push(c);
      }
    });

    comment.childComments = uniqueChildren;
  } else {
    comment.childComments.forEach((child) => flattenToLevel3(child, level + 1));
  }

  return comment;
};
const commentService = {
  async createComment(data) {
    try {
      const { forumId, userId, content, parentCommentId } = data;

      // Ki·ªÉm tra forum t·ªìn t·∫°i
      const forum = await Forum.findById(forumId);
      if (!forum) {
        return {
          status: STATUS_CODE.NOT_FOUND,
          message: "Forum kh√¥ng t·ªìn t·∫°i",
        };
      }

      // Ki·ªÉm tra user t·ªìn t·∫°i
      const user = await User.findById(userId);
      if (!user) {
        return {
          status: STATUS_CODE.NOT_FOUND,
          message: "User kh√¥ng t·ªìn t·∫°i",
        };
      }

      // T·∫°o comment m·ªõi
      const newComment = await Comment.create({
        forumId,
        userId,
        content,
        parentCommentId: parentCommentId || null,
      });

      // N·∫øu l√† reply ‚Üí th√™m v√†o childComments c·ªßa comment cha
      if (parentCommentId) {
        const parent = await Comment.findById(parentCommentId);
        if (parent) {
          parent.childComments.push(newComment._id);
          await parent.save();
        }
      }

      // üîπ Populate user ƒë·ªÉ frontend c√≥ email ngay l·∫≠p t·ª©c
      const populatedComment = await Comment.findById(newComment._id)
        .populate("userId", "email name avatar")
        .populate({
          path: "childComments",
          populate: { path: "userId", select: "email name avatar" },
        });

      return {
        status: STATUS_CODE.OK,
        message: "T·∫°o comment th√†nh c√¥ng",
        data: populatedComment,
        success: true,
      };
    } catch (error) {
      throw new Error(error);
    }
  },

  // üü¶ L·∫•y t·∫•t c·∫£ comment theo forumId
  // async getCommentsByForum(forumId) {
  //   console.log("forumId", forumId);
  //   try {
  //     const comments = await Comment.find({ forumId, status: "visible" })
  //       .populate("userId", "name email avatar")
  //       .populate({
  //         path: "childComments",
  //         populate: { path: "userId", select: "name email avatar" },
  //       })
  //       .sort({ createdAt: -1 });

  //     return {
  //       status: STATUS_CODE.OK,
  //       message: SYSTEM_MESSAGE.SUCCESS,
  //       data: comments,
  //     };
  //   } catch (error) {
  //     throw new Error(error);
  //   }
  // },
  // async getCommentsByForum(forumId) {
  //   try {
  //     // 1Ô∏è‚É£ L·∫•y t·∫•t c·∫£ comment trong forum
  //     const comments = await Comment.find({ forumId, status: "visible" })
  //       .populate("userId", "name email avatar")
  //       .lean(); // d√πng lean() ƒë·ªÉ d·ªÖ x·ª≠ l√Ω d·ªØ li·ªáu JS thu·∫ßn

  //     // 2Ô∏è‚É£ T·∫°o map ƒë·ªÉ tra c·ª©u comment nhanh
  //     const commentMap = {};
  //     comments.forEach((comment) => {
  //       comment.childComments = [];
  //       commentMap[comment._id.toString()] = comment;
  //     });

  //     // 3Ô∏è‚É£ X√¢y c√¢y cha‚Äìcon
  //     const rootComments = [];
  //     comments.forEach((comment) => {
  //       if (comment.parentCommentId) {
  //         const parent = commentMap[comment.parentCommentId.toString()];
  //         if (parent) {
  //           parent.childComments.push(comment);
  //         }
  //       } else {
  //         rootComments.push(comment);
  //       }
  //     });

  //     // 4Ô∏è‚É£ Tr·∫£ v·ªÅ k·∫øt qu·∫£
  //     return {
  //       status: STATUS_CODE.OK,
  //       message: SYSTEM_MESSAGE.SUCCESS,
  //       data: rootComments, // ch·ªâ tr·∫£ v·ªÅ comment g·ªëc, b√™n trong c√≥ children
  //     };
  //   } catch (error) {
  //     throw new Error(error);
  //   }
  // },

  async getCommentsByForum(forumId) {
    try {
      const comments = await Comment.find({ forumId, status: "visible" })
        .populate("userId", "name email avatar")
        .lean();

      const commentMap = {};
      comments.forEach((c) => {
        c.childComments = [];
        commentMap[c._id.toString()] = c;
      });

      const rootComments = [];
      comments.forEach((c) => {
        if (c.parentCommentId) {
          const parent = commentMap[c.parentCommentId.toString()];
          if (parent) parent.childComments.push(c);
        } else {
          rootComments.push(c);
        }
      });

      // üî• G·ªçi flattenToLevel3
      const result = rootComments.map((c) => flattenToLevel3(c));

      return {
        status: STATUS_CODE.OK,
        message: SYSTEM_MESSAGE.SUCCESS,
        data: result,
      };
    } catch (error) {
      throw new Error(error);
    }
  },
  // üü¢ Update comment
  async updateComment(id, userId, content) {
    try {
      const comment = await Comment.findById(id);
      console.log("comment", comment);
      if (!comment)
        return {
          status: STATUS_CODE.NOT_FOUND,
          message: "Comment kh√¥ng t·ªìn t·∫°i",
        };

      if (comment.userId.toString() !== userId.toString()) {
        console.log("h√∫ h√∫", comment.userId.toString(), userId.toString());
        return {
          status: STATUS_CODE.FORBIDDEN,
          message: "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠a comment n√†y",
        };
      }

      comment.content = content || comment.content;
      comment.updatedAt = new Date();
      await comment.save();

      return {
        status: STATUS_CODE.OK,
        success: true,
        message: "C·∫≠p nh·∫≠t comment th√†nh c√¥ng",
        data: comment,
      };
    } catch (error) {
      throw new Error(error);
    }
  },

  // üü£ Delete comment
  // async deleteComment(id, userId) {
  //   try {
  //     const comment = await Comment.findById(id);
  //     if (!comment)
  //       return {
  //         status: STATUS_CODE.NOT_FOUND,
  //         message: "Comment kh√¥ng t·ªìn t·∫°i",
  //       };

  //     if (comment.userId.toString() !== userId.toString()) {
  //       return {
  //         status: STATUS_CODE.FORBIDDEN,
  //         message: "B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a comment n√†y",
  //       };
  //     }

  //     comment.status = "deleted";
  //     await comment.save();

  //     return {
  //       status: STATUS_CODE.OK,
  //       message: "ƒê√£ x√≥a comment",
  //     };
  //   } catch (error) {
  //     throw new Error(error);
  //   }
  // },
  async deleteComment(id, userId) {
    try {
      const comment = await Comment.findById(id);
      if (!comment)
        return {
          status: STATUS_CODE.NOT_FOUND,
          message: "Comment kh√¥ng t·ªìn t·∫°i",
        };

      if (comment.userId.toString() !== userId.toString()) {
        return {
          status: STATUS_CODE.FORBIDDEN,
          message: "B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a comment n√†y",
        };
      }

      // G·ªçi h√†m ƒë·ªá quy x√≥a c√°c comment con
      await this._deleteChildComments(comment._id);

      // ƒê√°nh d·∫•u comment cha l√† deleted
      comment.status = "deleted";
      await comment.save();

      return {
        status: STATUS_CODE.OK,
        message: "ƒê√£ x√≥a comment v√† to√†n b·ªô comment con",
      };
    } catch (error) {
      throw new Error(error);
    }
  },

  // ===== H√†m ƒë·ªá quy =====
  async _deleteChildComments(parentId) {
    const childComments = await Comment.find({ parentCommentId: parentId });
    for (const child of childComments) {
      // G·ªçi l·∫°i ch√≠nh h√†m n√†y ƒë·ªÉ x·ª≠ l√Ω s√¢u h∆°n
      await this._deleteChildComments(child._id);
      child.status = "deleted";
      await child.save();
    }
  },

  // üü® B√°o c√°o comment
  async reportComment(commentId, userId, reason) {
    try {
      const comment = await Comment.findById(commentId);
      if (!comment) {
        return {
          status: STATUS_CODE.NOT_FOUND,
          message:
            COMMENT_ERROR_MESSAGE.COMMENT_NOT_FOUND || "Kh√¥ng t√¨m th·∫•y comment",
        };
      }

      // Ki·ªÉm tra user ƒë√£ report ch∆∞a
      const alreadyReported = comment.reported.some(
        (r) => r.user_id.toString() === userId
      );
      if (alreadyReported) {
        return {
          status: STATUS_CODE.CONFLICT,
          message: "B·∫°n ƒë√£ b√°o c√°o comment n√†y r·ªìi",
        };
      }

      comment.reported.push({ user_id: userId, reason });
      await comment.save();

      return {
        status: STATUS_CODE.OK,
        message: "B√°o c√°o comment th√†nh c√¥ng",
        data: comment,
      };
    } catch (error) {
      throw new Error(error);
    }
  },

  async reactComment(commentId, userId, action) {
    try {
      const comment = await Comment.findById(commentId);
      if (!comment) {
        return {
          status: STATUS_CODE.NOT_FOUND,
          message:
            COMMENT_ERROR_MESSAGE.COMMENT_NOT_FOUND || "Kh√¥ng t√¨m th·∫•y comment",
        };
      }
      // N·∫øu ng∆∞·ªùi d√πng c√≥ like tr∆∞·ªõc ƒë·ªõ:
      const hasLiked = comment.likedBy.includes(userId);
      const hasDisliked = comment.dislikedBy.includes(userId);
      console.log("hasLiked", hasLiked);
      console.log("hasDisliked", hasDisliked);

      if (action === "like") {
        if (hasLiked) {
          comment.like -= 1;
          comment.likedBy.pull(userId);
        } else {
          if (hasDisliked) {
            comment.like += 1;
          }
        }
      } else if (action === "dislike") comment.dislikes++;
      else
        return {
          status: STATUS_CODE.BAD_REQUEST,
          message: "H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá (ch·ªâ nh·∫≠n like/dislike)",
        };

      await comment.save();

      return {
        status: STATUS_CODE.OK,
        message: "Thao t√°c th√†nh c√¥ng",
        data: comment,
      };
    } catch (error) {
      throw new Error(error);
    }
  },
};

module.exports = { commentService };
